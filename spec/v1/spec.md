
# did:me Method Specification (v1)

**Status:** Beta  
**Specification URI:** https://really.me/ns/did-me/spec/v1  
**JSON-LD Context:** https://really.me/ns/did-me/v1

---

## 1. Introduction

`did:me` is a DID method designed for:

- Stable identifiers for individuals, pseudonymous personas, organizations, and groups
- Identifiers **not derived from cryptographic keys**, ensuring DID stability across rekeying
- CID-versioned core snapshots that define canonical DID state  
- Classical and post-quantum verification methods 
- Compatibility with EU Digital Identity Wallets, OpenID4VCI / OpenID4VP, and ZK-proof circuits  

The authoritative DID state is represented by a **core object**, encoded using canonical DAG-CBOR, hashed to a **CID**, and signed by the DID controller. The public DID Document is a JSON projection derived from this signed core.

`did:me` is centrally operated today (ReallyMe LLC hosts the authoritative registry), but the method is explicitly designed to support future decentralization through:

- Monotonic `sequence` counters for update ordering  
- `prev` links referencing the CID of the previous core
- A verifiable, tamper-evident chain of signed core snapshots  

---

## 2. DID Format

`did:me` identifiers are **not derived from keys or core CIDs**.  
This ensures DID stability even as keys rotate or services change.

### 2.1 DID Syntax

A `did:me` identifier MUST conform to:

~~~
did:me:<identifier>
~~~

Where `<identifier>` is the **full Bech32-encoded string**, including:
- the HRP `"me"`  
- the separator `"1"`  
- the 5-bit data payload  
- the Bech32 checksum  

Identifiers are generated by:

1. Generating **16 bytes (128 bits)** of cryptographically secure entropy  
2. Converting the entropy into **5-bit groups** (8→5 conversion, padded)  
3. Encoding the result via **Bech32** with HRP `"me"`  

**Formal representation:**

~~~
identifier = Bech32.encode(hrp="me", data=convertBits(entropy[16], 8→5))
~~~
The checksum included in the Bech32 output MUST be preserved, as it provides error-detection and guards against accidental corruption.

### 2.2 Allowed characters

The data portion of the Bech32 identifier (after "me1") MUST match Bech32’s lowercase character set:

~~~
^[023456789acdefghjklmnpqrstuvwxyz]+$
~~~


(Excludes: `1`, `b`, `i`, `o`.)


### 2.3 Length

Given 16 bytes of entropy:
-	16 bytes × 8 bits = 128 bits
- Converted to ~26 five-bit groups 
-	Bech32 encoding produces ~26–35 characters, including checksum


### 2.4 Example

~~~
did:me:me1q90w7wd0qpsl6rh6tsg4y0e0a60p3f60g
~~~

---

## 3. DID Resolution

### 3.1 Primary Resolution Endpoint

Given a DID:

~~~
did:me:<id>
~~~

the corresponding DID Document is obtained by:

~~~
GET https://reallyme.directory/dids/<id>
~~~

### 3.2 HTTP Status Codes

- `200 OK` — DID Document returned  
- `404 Not Found` — DID not registered  

---

## 4. Data Model Overview

A `did:me` DID Document is a standard DID Document projected from a signed core object and:
- Uses `verificationMethod`, `authentication`, `assertionMethod`, `capabilityInvocation`, `keyAgreement`, and `service` as defined in DID Core.
- Adds the following method-specific fields:
  - `sequence` — monotonic per-DID update counter  
  - `prev` — CID of the previous core (or `null`)  
  - `currentCore` — CID of the current DAG-CBOR core object  
  - `keyHistory` — ordered list of prior core CIDs 
  - `updatePolicy` — rules defining which verification methods may authorize updates  
  - `attestations` — signatures over the core object by the DID controller  
  - `proof` — optional Data Integrity Proof over `currentCore`  
  - `domainVerification` — optional DNS/HTTP proof binding the DID to a domain  


### 4.1 Method-Specific Extension Properties

`did:me` supports optional, method-specific properties that extend the base DID Document data model. These properties are defined in the did:me JSON-LD context:

https://really.me/ns/did-me/v1

The context defines terms such as:
- currentCore
- keyHistory
- attestations
- updatePolicy
- domainVerification
- and additional optional metadata fields (e.g., hardwareBound, biometricProtected, deviceModel)

All method-specific terms:
- MAY appear in a DID Document
- MUST NOT affect the validity of the core snapshot or signature
- MUST be ignored by processors that do not understand them, per DID Core rules
- MUST NOT change the canonical core object unless explicitly listed in the core schema

These extensions allow did:me to support richer metadata while preserving DID Core compatibility and forward extensibility.


---

## 5. Core Object

### 5.1 Purpose

The **core object** is the canonical representation of DID state. 
It is:

- encoded using **canonical DAG-CBOR**
- hashed to a **CID** (CIDv1, SHA-256, base32) 
- **signed** by the DID controller
- used to derive the public JSON DID Document (“projection”)

Although the DID string never changes, all mutable cryptographic state is reflected through successive, signed core snapshots.

`currentCore` contains the CID of the latest snapshot.
`keyHistory` contains only the CIDs of prior core snapshots, in ascending sequence order.
`prev` references the immediately preceding core CID and enforces canonical update ordering.

`prev` enables:
-	rollback prevention (reject older snapshots)
-	replay protection (reject repeated snapshots)
-	fork detection (reject alternative update branches)

This design provides:
-	deterministic state integrity
-	tamper-evident version history
-	key rotation without changing the DID
-	future support for decentralized or mirrored resolvers

### 5.2 Core Schema (Conceptual)

~~~
Core = {
  id: string,                     // "did:me:<id>"
  sequence: uint64,               // monotonic update counter
  prev: CID | null,               // CID of previous core (or null)
  controller: string | string[], // one or more controllers
  controllerKeys: [CoreKey],      // declared keys
  authenticationKeys: [string],   // references into controllerKeys
  assertionKeys: [string],
  keyAgreementKeys: [string],
  services: [CoreService],        // service endpoints
  updatePolicy: CoreUpdatePolicy,      // defines which verification methods may authorize updates
  updatedAt: RFC3339 timestamp
}
~~~
This schema represents exactly the content protected by the signature.
Anything not included here (e.g., proof, domainVerification) is not part of the core and does not affect DID validity.


A did:me DID MAY have one or more controllers.
If only one controller is present, it is typically the DID subject itself.

### 5.3 CoreKey Schema

~~~
CoreKey = {
  id: string,                     // e.g., "#ed25519"
  type: string,                   // e.g., "Multikey", "MLDSA87Key2024"
  algorithm?: string,             // optional (ES256, ML-DSA-87, etc.)
  publicKeyMultibase: string
}
~~~
Keys listed here define:
-	which verification methods exist
-	which methods can sign updates (via updatePolicy)
-	which methods serve authentication, assertion, invocation, or key agreement

All key relationship references (authenticationKeys, assertionKeys, keyAgreementKeys, and allowedVerificationMethods in updatePolicy) MUST refer to a CoreKey.id present in controllerKeys.

### 5.4 CoreUpdatePolicy 

The update policy is part of the canonical core object and defines 
which verification methods are authorized to sign core updates.

~~~
CoreUpdatePolicy = {
  allowedVerificationMethods: [string]   // references into controllerKeys by id.  These strings MUST match a CoreKey.id.
}
~~~

### 5.5 CoreService Schema

~~~
CoreService = {
  id: string,                     // "#hub", "#openid", "#wallet"
  type: string,                   // DID Core service type or did:me extension
  serviceEndpoint: any,           // URI or structured JSON
  version?: string
}
~~~
Service endpoints are part of the core snapshot and therefore immutable within each version.


### 5.6 Canonical CBOR Encoding

The core object MUST be encoded using canonical CBOR:
-	Map keys sorted lexicographically by UTF-8 bytes
-	Only definite-length arrays/maps
-	UTF-8 text keys
-	No undefined or extraneous fields
-	Deterministic encoding per RFC 8949 / DAG-CBOR restrictions

This ensures:
-	identical encoding across languages
-	identical CIDs across implementations
-	provable state integrity

Implementations MUST reject cores containing indefinite-length items or 
map keys not in strictly sorted order.

### 5.7 CID Derivation

The CID is computed as follows:

- **Codec**: `dag-cbor`  
- **Multihash**: `SHA-256`  
- **CID version**: v1 
- **Multibase**: base32 (lowercase)

This CID is published as:
~~~
"currentCore": "<cid>"
~~~

and used to verify signatures over the core.


---

## 6. Signatures and Attestations

### 6.1 Core Signature

Each core snapshot MUST be signed by the DID controller using one of the verification methods listed in:

~~~
updatePolicy.allowedVerificationMethods
~~~

The signature covers the **raw canonical DAG-CBOR bytes** of the core object.

These signatures are the authoritative root of trust for did:me and determine:
-	whether an update is valid
-	whether rollback, replay, or fork attempts are rejected
-	whether the currentCore CID matches its signed content

Core signatures appear in:

~~~
"attestations": [
  {
    "alg": "ML-DSA-87",
    "vm": "#mldsa87-root",
    "sig": "<base64url(signature-over-core-cbor)>"
  }
]
~~~
Multiple signatures MAY be present (e.g., Ed25519 and ML-DSA-87) to support multi-suite cryptography.


### 6.2 Optional Data Integrity Proof (P-256 Anchor)

A DID Document MAY include an optional W3C DataIntegrityProof using ES256 (P-256).
This proof is not authoritative for update validation (the core signatures are),
but it serves as an additional signature anchor, used by:
-	zero-knowledge proof circuits
-	EU EUDI Wallet compatibility
-	infrastructure that requires DI-standardized P-256 signatures

The Data Integrity Proof MUST sign the UTF-8 byte sequence of the currentCore CID string exactly as published in the DID Document.

~~~
"proof": {
  "type": "DataIntegrityProof",
  "cryptosuite": "me-es256-corecid-2025",
  "proofPurpose": "assertionMethod",
  "verificationMethod": "#p256",
  "created": "<ISO8601Z>",
  "jws": "<compact-jws-with-currentCore-as-payload>"
}
~~~

The DI proof:
-	MAY be omitted
-	MUST NOT be treated as the authoritative update signature
-	MUST match the currentCore CID exactly if present
-	MAY be validated by relying parties needing P-256 compatibility

---

## 7. Operations

### 7.1 Create

A new did:me identifier starts with:

~~~
sequence = 1
prev = null
~~~

Creation steps:

1.	Construct the initial core object
2.	Encode the core using canonical DAG-CBOR
3.	Compute currentCore as CIDv1 (dag-cbor, sha2-256)
4.	Sign the core bytes using an allowed verification method
5.	Publish the resulting DID Document at the registry endpoint

### 7.2 Update

To update a DID, the registry MUST enforce all of the following:

~~~
new.id == old.id
new.sequence == old.sequence + 1
new.prev == old.currentCore
signature(new-core-cbor) verifies under new.updatePolicy.allowedVerificationMethods
~~~

If any check fails, the update MUST be rejected.

A successful update produces:
-	a new core snapshot
-	a new currentCore CID
-	an appended entry in keyHistory
-	an updated DID Document projection


#### Multiple Controllers

A did:me DID MAY list one or more controllers.

An update is valid if and only if its signature verifies under a 
verification method that:

1. is listed in updatePolicy.allowedVerificationMethods, and
2. belongs to at least one controller.

Any single such verification method is sufficient.

### 7.3 Deactivate

To deactivate:
-	Publish a DID Document with completely empty verification relationships (e.g., empty verificationMethod, authentication, assertionMethod, and capabilityInvocation arrays).
-	Include a valid core signature from the controller or authorized recovery key.

After deactivation:
-	The resolver returns 404 Not Found for the DID.
-	A stored deactivated DID Document MAY still be published in a separate archival namespace for audit or compliance, but does not participate in resolution.


---

## 8. DID Document Projection

The DID Document is a JSON projection derived from the signed core. Validation MUST be performed against the core and its signatures, not the DID Document.

### 8.1 Field Mapping from Core

The following DID Document fields MUST be derived directly from the core:
- `id` → core.id
- `controller` → core.controller
- `sequence` → core.sequence
- `prev` → core.prev
- `currentCore` → CID of the canonical DAG-CBOR core snapshot
- `verificationMethod` → derived from core.controllerKeys
- `authentication` → derived from core.authenticationKeys
- `assertionMethod` → derived from core.assertionKeys
- `updatePolicy` → core.updatePolicy
- `capabilityInvocation` → derived from the appropriate core keys
- `keyAgreement` → derived from core.keyAgreementKeys
- `service` → derived from core.services
- `keyHistory` → ordered list of prior core CIDs

These fields MUST reflect the core exactly, and MUST NOT introduce information not present in the core snapshot.

### 8.2 Method-Specific Extensions (Non-Core Metadata)

The DID Document MAY include additional non-authoritative metadata that does not affect the core state:
- `attestations` — signatures over the core object
- `proof` — optional Data Integrity Proof (P-256) over currentCore
- `domainVerification` — optional DNS/HTTP domain-binding proof
- any other optional terms defined in the JSON-LD context at:
https://really.me/ns/did-me/v1

Processors that do not recognize these fields MUST ignore them, per DID Core rules.

#### 8.2.1 Domain Verification Objects

Each optional domainVerification entry MUST include:

- **type** (string) — the verification object type
("DnsTxtVerification" or "HttpsWellKnownVerification")
- **domain** (string)
- **method** (string)
- **proof** or **proofUrl** (depending on method)
- **verifiedAt** (timestamp)

Resolvers MUST accept at least one valid domain-verification method. Support for both is RECOMMENDED.


### 8.3 Requirements

- Reconstructing DID state MUST be possible using only the core snapshot and its signatures.
- The DID Document MUST NOT override or conflict with the contents of the signed core.
- Optional fields MUST NOT influence update authorization or core validity.
- The resolver MUST treat any mismatch between the core and projection as an error.





---

## 9. JSON-LD Context

The did:me JSON-LD context is published at https://really.me/ns/did-me/v1.


This context defines:
- method-specific terms (sequence, prev, currentCore, keyHistory)
- metadata terms (updatePolicy, attestations, domainVerification)
- service types (e.g., ReallyMeIdentityHub)
- optional device- or persona-related extensions (e.g., hardwareBound, biometricProtected, deviceModel)

All terms defined in the context:
- MAY appear in DID Documents
- MUST NOT influence the authoritative core state unless explicitly part of the core schema
- MUST be ignored by processors that do not understand them, per DID Core rules

The JSON-LD context MUST be included in all did:me DID Documents to guarantee consistent interpretation of method-specific terms.

---

## 10. Security Considerations

- **Rollback protection**: enforced through monotonic sequence values
- **Fork prevention**: enforced through prev linking the previous core snapshot
- **Tamper-evidence**: achieved via CIDv1 (SHA-256, DAG-CBOR) and core signatures
- **Authorized updates**: restricted to verification methods listed in updatePolicy
- **Canonical encoding**: core signatures MUST cover the canonical DAG-CBOR bytes
- **Projection safety**: DID Documents are non-authoritative projections; validators must rely on core + signatures
-	**Key rotation**: does not change the DID; state changes only via new core snapshots
- **Backup practices**: operators SHOULD maintain redundant storage of core snapshots and DID Documents
- **Cryptographic agility**: coexistence of classical (Ed25519, ES256) and post-quantum (ML-DSA-87, ML-KEM-1024) suites ensures long-term security

---

## 11. Future Decentralization

did:me is centrally operated today, but its structure enables future decentralized or federated deployments without breaking existing identifiers.

The method supports:
-	Mirror nodes - third-party read-only replicas of the registry
-	Verifiable replay - any resolver can reconstruct DID state by validating the chain of signed core snapshots
-	Multi-registry federation - multiple operators can publish equivalent core histories
-	Independent resolution - resolvers do not need to trust a single authoritative server

This is enabled by:
- sequence - enforces strict update ordering
- prev - links each core to the previous snapshot
- currentCore (CID) - cryptographic addressing of core snapshots
- signed canonical cores - guarantee tamper-evident integrity

These features allow did:me to evolve toward decentralized, distributed, or mirrored resolution models in the future.

